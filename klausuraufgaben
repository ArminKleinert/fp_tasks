1.
Definieren Sie eine squares Funktion in Haskel, die als Eingabe einer x, y Koordinate und size (Seitenlänge eines nxn Zeichenbild) bekommt, mit folgender Signatur

              squares :: (Int, Int, Int) -> Char

und bei Eingabe des Ausdrucks 

               paintChars squares 30

folgendes Zeichenbild-Muster produziert: (Bild)

Hier ist die paintChars Funktion, die die squares Funktion als Argument bekommt, um das Bild zu generieren und auf dem Bildschirm auszugeben:

paintChars f size = putStrLn (genChars f size)
genChars f size = paint size (map f [(x,y,size) | y <- [1..size], x <- [1..size]])
                  where
                  paint 0  []     = []
                  paint 0 (c:cs)  = '\n' : (paint size (c:cs))
                  paint n (c:cs)  = c: (paint (n-1) cs)
                  

2.
Betrachten Sie folgende Funktionsdefinitionen:

natFold :: (a->a) -> a -> Integer -> a
natFold  h  c  0 = c
natFold  h  c  n = h (natFold  h  c  (n-1))

g :: Integer -> Integer -> Integer 
g  n  m  =  natFold (*n) 1 m

iterate :: (a -> a) -> a -> [a]
iterate f a = a: iterate f (f a)

Reduzieren Sie schrittweise folgende drei Haskell-Ausdrücke zur Normalform. Schreiben Sie mindestens vier Reduktionsschritte pro Ausdruck und begründen Sie Ihre Antwort. 

     take 4 (iterate  (g 2) 1)
     ((foldl (+) 0) . (map (g 2))) [1..4]
     length [x | xs<-["one", "two", "three"], x<-xs]


3.
Betrachten Sie folgende Funktionsdefinitionen:

span p [] = ([],[])
span p (x:xs) | p x          = (x:ys, zs)
                     | otherwise = ([], (x:xs))
                                           where (ys,zs) = span p xs

unfold p f g x | p x = []
                     | otherwise = f x : unfold  p  f  g  (g x)

Reduzieren Sie folgende Ausdrücke schrittweise zur Normalform. Schreiben Sie mindestens drei Zwischenschritte pro Ausdruck und begründen Sie Ihre Antwort.

a)  span (/=' ') "Hi world"

b)  unfold (4<) ((*2).(`mod`3)) (1+) 1

4.
Schreiben Sie eine Haskell Funktion serie, die bei Eingabe einer Gleitkommazahl x und einer natürlichen Zahl n folgende Seriensumme von 0 bis zum n-Wert berechnet. Die Fakultät Funktion muss als Hilfsfunktion definiert werden. (Bild)


5.
Betrachten Sie folgende Funktionsdefinition, die eine beliebig lange Liste von Primzahlen berechnet:

primes = sieb [2..]
               where
                   sieb (p:xs) = p:sieb[k | k<-xs, (mod k p)>0]

Programmieren Sie damit eine prime3 Funktion, die als Argument eine natürliche positive Zahl n bekommt und die die ersten n Primzahlen berechnet, die mit der Ziffer 3 enden.

      Anwendungsbeispiel:   

                   prime3  7  =>  [3, 13, 23, 43, 53, 73, 83]

6.
Definieren Sie eine rekursive, polymorphe Funktion applyWhile, die als Argumente eine Funktion f (f :: a -> b), eine Prädikat-Funktion p (p :: a->Bool) und eine Liste bekommt und solange die Elemente der Liste das Prädikat p erfüllen, die Funktion f auf die Elemente der Liste anwendet und diese in die Ergebnisliste einfügt. 

       Anwendungsbeispiel:   

               applyWhile (`div` 3) (<15) [3, 6, 12, 8, 18, 3, 9] => [1,2,4,2]


7.
In einer Liste aus vergleichbaren Elementen wird ein lokales Minimum als das Element definiert, das streng kleiner ist als die Elemente, die unmittelbar davor und danach stehen.

a) Definieren Sie eine endrekursive polymorphe Funktion, die bei Eingabe einer Liste, die Liste aller lokalen Minima berechnet.

    Anwendungsbeispiele:

         listLocalMins [2, 4, 5, 1, 6, 5, 4, 3, 2, 7] => [1, 2]
         listLocalMins [1.0, 2.0, 3.0, 3.0, 4.0, 5.0] => []
         listLocalMins "local minimum"  =>  "a ii"

b) Analysieren Sie die Komplexität ihrer Funktion.

8.
Definieren Sie eine Funktion sumMultiple, die bei Eingabe von zwei natürlichen Zahlen k und n, die Summe aller Mehrfachen von k zwischen 1 und n unter Verwendung der foldl und filter-Funktionen berechnet. Sie dürfen in Ihrer Definition keine Listengeneratoren verwenden.

            Anwendungsbeispiel:   sumMultiple  3 10 => 18

9.
Definieren Sie eine nicht curryfizierte Version der Haskell filter-Funktion.

10.
Definieren Sie eine Funktion compress, die eine Liste von Bits bekommt und diese in kompakter Form zurückgibt, indem sie nebeneinander stehende gleiche Bits mit einer Zahl zusammenfasst. Definieren Sie zuerst einen algebraischen Datentyp Bits dafür.

    Anwendungsbeispiele:

             compress  [One, Zero, Zero, One, One, One, One]  => [1,2,4]

             compress  [Zero, Zero, Zero, Zero, One, One, Zero, Zero] => [4,2,2]
