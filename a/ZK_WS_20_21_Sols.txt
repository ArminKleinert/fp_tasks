
113.12.2019Funktionale Programmierung   WS 2020/2021 Prof. Dr. Margarita Esponda ZwischenklausurWichtige Hinweise: 1)Speichern Sie regelmäßig die Zwischenergebnisse der einzelnen Fragen und kontrollieren Sie nach der Speicherung vor allem die Korrektheit der Einrückung aller Haskell-Programme.  2)Im Antwortfeld öffnen Sie den Rich-Text Editor, indem Sie dafür den entsprechenden Knopf oben rechts sehen können, um ihre Antworten korrekt zu formatieren. Die Haskell-Funktionen sollen mit Hilfe von Leerzeichen korrekt eingerückt werden, sonst werden Punkte abgezogen. 3)Öffnen Sie die Klausur nur in einem Tab/Browserfenster und auf einem einzigen Gerät. 4)Wenn Sie früher fertig sind, geben Sie bitte die Zwischenklausur explizit ab, bevor Sie das Fenster zu machen, andernfalls können Sie technische Probleme bekommen. 5)Verwenden Sie die vorgegebenen Funktionsnamen und/oder Variablennamen für die Aufgaben. 6)Die Zwischenklausur ist zeitaufwendig. Bei der Korrektur wird eine relative Einstufung für die Benotung verwendet. D.h. wenn die besten Studierenden z.B. überwiegend nur 80 Prozent der Punkte erreicht haben, werden die Noten zwischen 0-80 Punkte gleichmässig verteilt. Viel Erfolg! Zwischenklausur am 13. 12. 2019
213.12.20191.Aufgabe (8 Punkte) Definieren Sie eine squares Funktion in Haskel, die als Eingabe einer x, y Koordinate und size (Seitenlänge eines nxn Zeichenbild) bekommt, mit folgender Signatur: squares :: (Int, Int, Int) -> Char die bei Eingabe des Ausdrucks  paintCharssquares 30 folgendes Zeichenbild-Muster produziert: Hier ist die paintChars Funktion, die die squares Funktion als Argument bekommt, um das Bild zu generieren und auf dem Bildschirm auszugeben: paintChars f size = putStrLn (genChars f size) genChars f size = paint size (map f [(x,y,size) | y <- [1..size], x <- [1..size]]) where                  paint 0  []     = []                   paint 0 (c:cs)  = '\n' : (paint size (c:cs))                   paint n (c:cs)  = c: (paint (n-1) cs)Zwischenklausur am 13. 12. 2019
313.12.2019Lösung 1, G1:square :: (Int, Int, Int) -> Char square (x, y, size) | inSmallSquare = ' '                            | inBigSquare     = '*'                            | otherwise      = '.' where                                    s6 = div size 6                                     inBigSquare  = x>s6 && x<=5*s6 && y>s6 && y<=5*s6                                     inSmallSquare = x>2*s6 && x<=4*s6 && y>2*s6 && y<=4*s6 Lösung 2, G1: square :: (Int, Int, Int) -> Char square (x,y,size) | y<s || y>5*s || x<s || x>5*s = '.'                          | y<2*s || y>4*s || x<2*s || x>4*s = '*'                          | otherwise = ' ' where                                            s = div size 6 Lösung 3, G1:squares :: (Int, Int, Int) -> Char squares (x, y, size) | inSmallSquare = ' '                              | inBigSquare   = '*'                              | otherwise     = '.' where                                 s6 = div size 6                                  s3 = div size 3                                  inBigSquare  = x>s6 && x<=5*s6 && y>s6 && y<=5*s6                                  inSmallSquare = x>s3 && x<=2*s3 && y>s3 && y<=2*s3 Zwischenklausur am 13. 12. 2019

