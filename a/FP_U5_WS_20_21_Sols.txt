
Ziel: Arbeiten mit Funktionen höherer Ordnung, endrekursiven Funktionen und Komplexitätsanalyse von Funktionen. 1.Aufgabe (3 Punkte)Im Haskell-Prelude ist die iterate-Funktion wie folgt definiert: iterate  :: (a -> a) -> a -> [a] iterate f x   =  x : iterate f ( f x ) Definieren Sie unter Verwendung der iterate-Funktion Funktionen, die folgende unendlichen Listen darstellen: [1, -1, 1, -1, 1, -1, ...]        [0, 1, 3, 7, 15, 31, 63, ...]        [(0,1), (1,1), (1,2), (2,3), (3,5), (5,8), ...] Lösung: list1 = iterate (*(-1)) 1 list2 = iterate ((+1).(*2)) 0 nextFib :: (Int,Int) -> (Int,Int) nextFib (a,b) = (b, a+b) list3 = iterate  nextFib (0,1) 2. Aufgabe(4 Punkte) Analysieren Sie die Komplexität folgender zwei Multiplikationsfunktionen: mult :: Integer -> Integer -> Integer mult n 0 = 0 mult n m = mult n (m-1) + n russMult :: Integer -> Integer -> IntegerrussMult n 0 = 0 russMult n m | (mod m 2)==0  = russMult (n+n) (div m 2)                     | otherwise          = russMult (n+n) (div m 2) + n Lösung:  Die Eingabegröße ist: m = das 2. Argument der mult Funktion In der mult Funktion findet die Rekursion über das zweite Argument von (m-1) bis 0 statt. D.h. die maximale Anzahl von rekursiven Aufrufen ist gleich m. Zum Schluss wird m-Mal nzusammenaddiert.Seite  von 18WS 2020/2021Funktionale Programmierung 5. Übungsblatt     Prof. Dr. Margarita EspondaT(m)=2⋅m∈O(m)
Die Eingabegröße ist: m = 2. Argument der russMult Funktion In der russMult Funktion wird die Rekursion nur so lange durchgeführt, bis m durch 2ungleich 0 ist. D.h. so lange m noch ganzzahlig teilbar ist. Das entspricht dem Logarithmus Basis 2 von m.3. Aufgabe(6 Punkte) a)Schreiben Sie eine Haskell Funktion, das einen Text als Eingabe bekommt und alle Worte, die sich mit den letzen drei Buchstaben reimen, in eine Liste von Gruppenworten klassifiziert. Anwendungsbeispiel: classifyRhymeWords  "Nikolaus baut ein Haus aus Holz und klaut dabei ein Bauhaus."  =>    [[“klaut“,"baut"],["Nikolaus","Bauhaus","Haus","aus"],["ein","ein"],["dabei"],["und"],["Holz"]] Lösung:delimiter :: Char -> Bool delimiter c = elem c [',', '.', '?', '!', ' ', '\n', '\t'] text2words :: [Char] -> [[Char]] text2words [] = [] text2words ws = text2words' [] [] ws                     where                     text2words' acc [] []      = acc                     text2words' acc word []    = word:acc                     text2words' acc word (x:rest) | delimiter x  = text2words' (word:acc) [] rest                                                   | otherwise    = text2words' acc (word++[x]) rest groupSamePrefix :: [[Char]] -> [[[Char]]] groupSamePrefix  []    = [] groupSamePrefix [word] = [[word]] groupSamePrefix  ws    = gPrefix [] [] ws                          where                          gPrefix xs []  []  = xs                          gPrefix xs rws []  = rws:xs                          gPrefix xs []  (w:ws) = gPrefix xs [w] ws                          gPrefix xs (rw:rws) (w:ws) | samePrefix rw w = gPrefix xs (w:rw:rws) ws                                                     | otherwise       = gPrefix ((rw:rws):xs) [w] ws                          samePrefix (x:y:z:rest) (x':y':z':rest') = (x,y,z) == (x',y',z')                          samePrefix a b = a==b classifyRhymeWords :: [Char] -> [[[Char]]] classifyRhymeWords text = map (map reverse) (groupSamePrefix (startMergeSort (text2words                                                                                                                                            (reverse text)))) b)Analysieren Sie die Komplexität der Funktion. Seite  von 28T(m)=c⋅log2(m)=O(log2m)mitc=Berechnungsaufwandder(+),divundmodFunktionen.
