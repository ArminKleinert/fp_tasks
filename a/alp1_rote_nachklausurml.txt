AlgorithmenundProgrammieren1FunktionaleProgrammierungWS2011/2012NachklausurMusterlösungJulianFleischer,TereseHaimb erger,NicolasLehmann,ChristopherPo ckrandt,AlexanderSteen24.03.2012Aufgab e1:15PunkteSchreib enSieeineFunktiontiefeKonst::            Ausdruck            ->            Int,diedieTiefederamtiefstenge-schachteltenKonstantenineinemarithmetischenAusdruckb estimmt.WennderAusdruckkeineKonstantenenthält,solldasErgebnis-1sein.DerDatentypfürarithmetischeAusdrückeistfol-gendermaÿendeniert:data            Ausdruck            =            Konst            Integer            |            Var            String            |            Plus            Ausdruck            Ausdruck|            Mal            Ausdruck            Ausdruck            deriving            (Eq,            Show)Beispiele:tiefeKonst            (Konst            5)                                                                                                                                                                                                                                                                                                                                                                                                                         =            0tiefeKonst            (Plus            (Var            "a")            (Konst            5))                                                                                                                                                                                                             =            1tiefeKonst            (Plus            (Var            "a")            (Var            "b"))                                                                                                                                                                                                             =            (-1)tiefeKonst            (Plus            (Mal            (Var            "x")            (Konst            2))            (Konst            5))            =            2BeiallenFunktionenistwieimmereineTyp deklarationanzugeb en.LösungzuAufgab e1--            Bestimmt            die            Tiefe            der            am            tiefsten            geschachtelten            Konstanten            in            einem            Ausdruck.tiefeKonst            ::            Ausdruck            ->            InttiefeKonst            e                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      --            e            =            Ausdruck|            tiefeListe            ==            []            =            -1                                                                                                                                                                                                                                                             --            -1,            falls            kein            Konst            im            Ausdruck|            otherwise                                                                                                =            maximum            (tiefeListe)                                    --            bestimmt            maximale            Tiefe            sonstwheretiefeListe            =            expr2list            e            0                                                                                                                                                             --            Aufruf            der            Hilfsfunktion--            Macht            aus            einem            Ausdruck            eine  
Aufgab e2:15PunkteWelcheVariablenkommenimAusdruckλx.((λx.λa.(ax(bx)yx))(λb.xb))gebundenvor?WelcheVariablenkommenfreivor(b ezogenaufdengesamtenAusdruck)?ReduzierenSiedenAusdrucksoweitwiemöglich.LösungzuAufgab e2λx.((λx.λa.(ax(bx)yx))(λb.xb))GebundeneVariablen:x,a,bFreieVariablen:b,yβ-Reduktion:λx.((λx.λa.(ax(bx)yx))(λb.xb))=⇒βλx.((λa.(a(λb.xb)(b(λb.xb))y(λb.xb))))Aufgab e3:20PunkteSchreib enSieeinHaskell-Programmvielfachheit::[Int]            ->            [Int],dasfüreineEingab elistexvonnichtnegativenZahlenzählt,wieoftjedeZahlinihrenthaltenist.DasErgebnisisteineListeb,wob eib!!iangibt,wieoftiinxvorkommt.Beispiel:vielfachheit            [1,3,5,3,1]            =            [0,2,0,2,0,1]VerwendenSieKommentarezurErläuterungIhresProgramms.BeiallenFunktionenistwieimmereineTyp deklarationanzugeb en.AnalysierenSiedieasymptotischeLaufzeitIhresProgramms.Üb erlegenSiedazu,vonwelchenParameternderEingab edieLaufzeitabhängt,undgeb enSiedanneineob ereSchrankefürdieLaufzeitinO-Notationan.SiedürfendieFunktionsortausdemMo dulData.Listverwenden,dieeineFolgederLängenmitLaufzeitO(n·log(n))sortiert.LösungzuAufgab e3--            Zählt            das            Vorkommen            jeder            Zahl            x            aus            dem            Intervall            [0;maximum            xs]            und            speichert--            dieses            in            einer            Ergebnisliste.vielfachheit            ::            [Int]            ->            [Int]vielfachheit            xs            =            [(length            (filter            (==x)            xs))            |            x            <-            [0..(maximum            xs)]]Laufzeit:=⇒O(n︸︷︷︸length·n︸︷︷︸filter·(maximumxs+ 1)) =O(n2·(maximumxs+ 1))2
AlternativeLösungzuAufgab e3--            Zählt,            wie            oft            eine            Zahl            in            der            Eingabeliste            enthalten            ist.--            Die            Funktion            vielfachheit            ruft            eine            Hilfsfunktion            auf.vielfachheit::            [Int]            ->            [Int]vielfachheit            []            =            []vielfachheit            xs            =            helper            xs            (maximum            xs)            []                                                                                                                                                                                                             --            Aufruf            der            Hilfsfunktion--            Die            Hilfsfunktion            baut            mit            Hilfe            einer            gegen            (-1)            strebenden            Positionsvariablen            eine--            Ergebnisliste            rückwärts            zusammen.helper            ::            [Int]            ->            Int            ->            [Int]            ->            [Int]helper            list            (-1)            resultlist                        =            resultlist                                                                                                                                                                                                                                     --            Anker:            Ergebnisliste            ausgebenhelper            list            position            resultlist                                                                                                                                                                                                                                                                                                                                                             --            Ergebnisliste            zusammenbauen|            (filter            (==position)            list)            ==            []            =            helper            (list)            (position-1)            (0:resultlist)|            otherwise                                                                                                                                                                                                                                                                                                 =            helper            (filter            (/=position)            list)            (position-1)((length            (filter            (==position)            list)):resultlist)Laufzeiten:=⇒O(n·n·(maximumxs+ 1)︸︷︷︸helper+n︸︷︷︸maximum) =O(n2·(maximumxs+ 1))Aufgab e4:20PunkteWelcheFormelmussmanfürxeinsetzen,damitdieGleichungdrop            m            .            drop            n            =            drop            (x)fürallemundn(auchfürnegativeWerte)gilt?BeweisenSiedieGleichungdanndurchstrukturelleInduktion(o derdurcheineandereMetho-deIhrerWahl)unterVerwendungderfolgendenDenitionen:drop            ::            Int            ->            [a]            ->            [a](d1)            drop            n            xs            |            n            <=            0            =            xs(d2)            drop            _            []                                                                                                                        =            [](d3)            drop            n            (_:xs)                                                                        =            drop            (n-1)            xsLösungzuAufgab e4MöglicheLösungenfürx:x            =            ((max            m            0)            +            (max            n            0))x            =            fkt            m            n|            m            <=            0            &&            n         
EsfolgteinBeweismitstrukturellerInduktionüb erxs.zuzeigen:drop            m            .            drop            n            =            drop            ((max            m            0)            +            (max            n            0))⇐⇒drop            m            (drop            n            xs)            =            drop            ((max            m            0)            +            (max            n            0))            xsInduktionsbasis:xs            =            []drop            m            (drop            n            [])            =            drop            ((max            m            0)            +            (max            n            0))            []⇐⇒d2drop            m            []            =            drop            ((max            m            0)            +            (max            n            0))            []⇐⇒d2[]            =            drop            ((max            m            0)            +            (max            n            0))            []⇐⇒d2[]            =            []Induktionsvoraussetzung:FüreineListexsmitb eliebiger,ab erfesterLängegilt:drop            m            (drop            n            xs)            =            drop            ((max            m            0)            +            (max            n            0))            xsInduktionsb ehauptung:Danngiltauch:drop            m            (drop            n            (x:xs))            =            drop            ((max            m            0)            +            (max            n            0))            (x:xs)Induktionsschritt:xs−→(x:xs)drop            m            (drop            n            (x:xs))            =            drop            ((max            m            0)            +            (max            n            0))            (x:xs)Fall1:m <= 0,n <= 0drop            m            (drop            n            (x:xs))            =            drop            0            (x:xs)⇐⇒d1drop            m            (drop            n            (x:xs))            =            drop            0            (x:xs)⇐⇒d1drop            m            (x:xs)            =            drop            0            (x:xs)⇐⇒d1(x:xs)            =            drop            0            (x:xs)⇐⇒d1(x:xs)            =            (x:xs)Fall2:m >0,n <= 0drop            m            (drop            n            (x:xs))            =            drop            m            (x:xs)⇐⇒d1drop            m            (x:xs)            =            drop            m            (x:xs)Fall3:m <= 0,n >0drop            m            (drop            n            (x:xs))            =            drop            n            (x:xs)⇐⇒d1drop            n            (x:xs)            =            drop            n            (x:xs)Fall4:m >0,n >0drop            m            (drop            n            (x:xs))            =            drop            (m+n)            (x:xs)⇐⇒d3drop            m            (drop            (n-1)            xs)            =            drop            (m+n)            (x:xs)⇐⇒d3drop            m            (drop            (n-1)            xs)            =            drop            (m+n)-1            xs⇐⇒assoz.drop            m            (drop            (n-1)            xs)            =            drop            m+(n-1)            xs⇐⇒IVdrop            m+(n-1)            xs            =            drop            m+(n-1)            xsEswurdemitstrukturellerInduktiongezeigt,dassdieBehauptunggilt.4
Aufgab e5:15PunkteDiefolgendenFunktionensinddeniert:rotate            xs            (y:ys)            rys            =            if                                    xs            ==            []then            y:ryselse            (head            xs):(rotate            (tail            xs)            ys            (y:rys))folge            n            =            n:(folge            (n+1))Beschreib enSie,wieHaskelldenAusdrucktake            6            (rotate            [2,4,5]            (folge            5)            (folge            9))SchrittfürSchrittauswertet.AchtenSiedarauf,dassFunktionennichtausgewertetwerden,b evorihrWertb enötigtwird.LösungzuAufgab e5take            4            (rotate            [2,4,5]            (folge            5)            (folge            9))take            4            (rotate            [2,4,5]            (5:(folge            6))            (folge            9))take            4            (2:(rotate            [4,5]            (folge            6)            (5:(folge            9))))2:            take            3            (rotate            [4,5]            (folge            6)            (5:(folge            9)))2:            take            3            (rotate            [4,5]            (6:(folge            7))            (5:(folge            9)))2:            take            3            (4:(rotate            [5]            (folge            7)            (6:5:(folge            9))))2:4:            take            2            (rotate            [5]            (folge            7)            (6:5:(folge            9)))2:4:            take            2            (rotate            [5]            (7:(folge            8))            (6:5:(folge            9)))2:4:            take            2            (5:(rotate            []            (folge            8)            (7:6:5:(folge            9))))2:4:5:            take            1            (rotate            []            (folge            8)            (7:6:5:(folge            9)))2:4:5:            take            1            (rotate            []            (8:(folge            9))            (7:6:5:(folge            9)))2:4:5:            take            1            (8:7:6:5:(folge            9))2:4:5:8:            take            0            (7:6:5:(folge            9))2:4:5:8:            [][2,4,5,8]Aufgab e6:5PunkteBestimmenSiedenallgemeinstenTyp,dendieFunktionfhab enkann.f            a            b            c|            a            b                                                                                    =            a            b|            otherwise            =            a            cBegründenSieSchrittfürSchritt,wieSiezuIhrenSchlussfolgerungenkommen.LösungzuAufgab e6•Ausa            bimerstenGuardkannmanschlieÿen,dassdieFunktionaeineFunktionvomTyp(x            ->            Bool)ist,wob eixderTypvonbist.f::(x            ->            Bool)            ->            (x)            ->            (?)            ->            (?)•DadasErgebnisdeserstenGuardsaucha            bist,istderErgebnistypderFunktionBoolf::(x            ->            Bool)            ->            (x)            ->            (?)            ->            Bool•DaderErgebnistypderFunktioninjedemGuardgleichseinmuss,hatdieFunktiona            cimzweitenGuarddenselb enErgebnistypwiedieFunktiona            b.Wirkönnendirektdarausfolgern,dasscdenselb enTyphatwieb,dab eideParameterderFunktionasind.f::(x            ->           Bool) -> (x) -> (x) -> Bool
