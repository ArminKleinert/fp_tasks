1. Aufgabe (9 Punkte)Betrachten Sie folgende Funktionsdefinitionen: apply :: (a -> b, a -> c) -> a ->  (b, c) apply (f, g) x = (f x, g x) cross :: (a -> b, c -> d) -> (a, c) -> (b, d) cross (f, g) = apply (f . fst, g . snd)Was ist der Wert folgender Ausdrücke? Begründen Sie Ihre Antwort oder schreiben Sie mindestens vier Zwischenschritte Ihrer Berechnungen auf.a) cross ((mod 2), (==1) . (div 9)) (4, 7)Lösung:cross ( (mod 2), (==1) . (div 9) ) (4, 7)             => apply ( (mod 2) . fst, ( ((==1) . (div 9)) . snd ) (4,7) => ( ((mod 2) . fst) (4,7), ( ((==1) . (div 9)) . snd ) (4,7) )=> ( (mod 2) (fst (4,7)),  ((==1) . (div 9)) (snd (4,7)) )=> ( (mod 2) 4,  ((==1) . (div 9)) 7 )=> ( 2,  ((==1) . (div 9)) 7 )=> ( 2,  (==1) ((div 9) 7) )=> ( 2,  (==1) 1 )- -  3 P.=> (2, True)                                                                - -  2 P.b) foldl (\ys x-> x:ys) [] (take 3 [1..])    =>   (foldl (\ys x-> x:ys) []  [1,2,3]     =>   (foldl (\ys x-> x:ys) 1:[]  [2,3]     =>   (foldl (\ys x-> x:ys) 2:[1]  [3]     =>   (foldl (\ys x-> x:ys) 3:[2,1]  []     =>   (foldl (\ys x-> x:ys) [3,2,1]  []                                 - -  3 P.    =>   [3,2,1]                                                                    - -  1 P.ProInformatik II, M. Esponda   
Klausur am 20. Februar 20172. Aufgabe(11 Punkte)Betrachten Sie folgendes Anwendungsbeispiel der currifiziertenzipWithStandardfunktion von Haskell:                    zipWith (^) [1, 2, 3] [2, 3, 4] => [1, 8, 81] a)Definieren Sie eine uncurrifizierte Version der zipWithFunktion. b)Schreiben Sie eine sinnvolle Definition der zipWith Funktion, mit Hilfe von Listengeneratoren. Sie dürfen dabei andere Standardfunktionen von Haskell verwenden.Lösungen a), b): zipWith_b :: ((a -> b -> c), [a], [b]) -> [c] - -  2 P.zipWith_b (f, [], _) = [] - -  1 P.zipWith_b (f, _, []) = [] - -  1 P.zipWith_b (f, (x:xs), (y:ys)) = (f x y): zipWith_b (f, xs, ys)       - -  1 P.zipWith_a ::(a -> b -> c) -> [a] -> [b] -> [c] - -  2 P.zipWith_a  f  xs  ys = [ f a b | (a,b) <- zip xs ys ]  - -  4 P.ProInformatik II, M. Esponda                                                                                                           !3
Klausur am 20. Februar 20173. Aufgabe(10 Punkte)Die freq-Funktion berechnet, wie oft ein angegebenes Element in einer Liste vorkommt.  Anwendungsbeispiele: freq  3  [2, 1, 4, 8, 9, 3, 3, 0] => 2 freq  'a'  "abcdea abda" => 4 Schreiben Sie eine Definition der freq-Funktion, unter sinnvoller Verwendung der foldl-Funktion.  1. Lösungfreq' :: (Eq a) => a -> [a] -> Int      - -  2 P.freq' a  = foldl count_reps 0   - -  8 P. where                   count_reps n y   | y==a       = n+1 | otherwise = n   2. Lösungfreq :: (Eq a) => a -> [a] -> Int - -  2 P.freq a  = foldl (\x y -> if (y==a) then x+1 else x) 0 - -  8 P.ProInformatik II, M. Esponda                                                                                                           !4
Klausur am 20. Februar 20174. Aufgabe (6 Punkte)Betrachten Sie folgendes Datentyp-Synonym mit entsprechenden Funktionsdefinitionen für Zahlenmengen:type Set = [Int]inSet :: Int -> Set -> Bool inSet e  []  = False inSet e (x:xs) | e == x = True                      | otherwise = inSet e xs(\\) :: Set -> Set -> Set (\\) setA setB = [x| x<-setA, not (inSet x setB)]b) Analysieren Sie die Komplexität der (\\) Funktion.Lösung:Die (\\) Funktion ist so definiert, dass jedes Element x aus der Menge setA in der Menge setB gesucht wird. Im besten Fall hat setA oder setB nur ein Element, weil dann die Komplexität gleich O(n) ist. Im schlimmsten Fall haben setA und setB die gleiche Anzahl von Elementen und kein Element von setA befindet sich in setB, weil dann jedes Element x von setA mit allen Elementen der Menge setB verglichen wird.  Wenn n die Anzahl der Elemente in setA und in setB ist bzw. die Länge der Listen ist, ist die Komplexität der (\\) Funktion gleich O(n2). ProInformatik II, M. Esponda                                                                                                           !5T(\\)(n,n)=T(\\)(n−1,n)+c1⋅T(inSet)(n)+c2=T(\\)(n−1,n)+O(n)+c2--4p.=O(n2)--2p.mitc1=ZeitkosteneinesrekursivenAufrufsderinSetFunktionc2=Zeitkostendernot+GenerierungeinesElementsdesListengenerators
Klausur am 20. Februar 20175. Aufgabe(14 Punkte)Betrachten Sie folgende algebraische Datentypen und Funktionen: data  Nat  =  Zero  | S Nat  deriving Showdata ZInt = Z Nat Nat  deriving Showdata B = T | F deriving Showadd ::  Nat-> Nat-> Natadd a Zero = a add a (S b) = add (S a) bmult :: Nat -> Nat -> Nat mult _ Zero  = Zero   mult a (S b) = add a (mult a b)foldn :: (Nat -> Nat) -> Nat -> Nat -> Nat foldn  h  c  Zero  = c foldn  h  c  (S n) = h (foldn  h  c  n)a) Definieren Sie damit eine smaller (<)und eine equal (==) Funktion für den Datentyp Nat. Lösung:            smaller :: Nat -> Nat -> B smaller Zero (S _) = T smaller (S a) (S b) = smaller a b smaller _ _ = F- -  3 P.equal :: Nat -> Nat -> B equal Zero Zero = T equal (S a) (S b) = equal a b equal _ _ = F- -  3 P.b) Definieren Sie die Potenzfunktion power für den Datentyp Nat (natürliche Zahlen) unter Verwendung der foldn Funktion.      1. Lösung: power :: Nat -> Nat -> Nat               (hier ist 00=1 und wird als Lösung akzeptiert) power m = foldn (mult m) (S Zero) - -  4 P.2. Lösung: power :: Nat -> Nat -> Nat power Zero Zero = error“... not defined” power m n = foldn (mult m) (S Zero) n     - -  4 P.ProInformatik II, M. Esponda                                                                                                           !6
Klausur am 20. Februar 2017c) Definieren Sie die (<) Funktion für den Datentyp ZInt (ganze Zahlen). Lösung: (<<) :: ZInt -> ZInt -> B (<<)  (Z a b) (Z c d) = smaller (add b c) (add a d)               - -  4 P.6. Aufgabe (8 Punkte)Betrachten Sie folgenden algebraischen Datentyp für einfache binäre Bäume:dataSimpleBT  =  L | N  SimpleBT  SimpleBTDefinieren Sie damit folgende Funktionen:  height :: SimpleBT -> Integer      - - berechnet die Höhe des Baumesbalanced :: SimpleBT -> Bool      - - entscheidet, ob der Baum vollständig- - bzw. balanciert ist oder nicht.Wenn Sie dafür zusätzliche Funktionen brauchen, müssen Sie diese auch definieren. Lösung: height :: SimpleBT -> Integer height L = 0 height (N lt rt) = (max (height lt) (height rt)) + 1   — 4 P.balanced :: SimpleBT -> Bool balanced  L = True balanced  (N lt rt) = (balanced lt) && (balanced rt) && height lt == height rt — 4 P. ProInformatik II, M. Esponda                                                                                                           !7
Klausur am 20. Februar 20177. Aufgabe(12 Punkte)Betrachten Sie folgende Funktionsdefinitionen: length :: [a] -> Int length [] = 0   . . . . . . . . . . . . . . . . . . length.1 length (x:xs) = 1 + length xs  . . . . . . . . . . . . . . . . . . length.2 replicate :: Int -> a -> [a] replicate 0 _ = [] . . . . . . . . . . . . . . . . . replicate.1replicate (n+1) x = x: replicate n x . . . . . . . . . . . . . . . . . replicate.2 Beweisen Sie mittels vollständiger Induktion über n folgende Eigenschaft: length (replicate n x) = nInduktionsanfang:    n = 0              ?                            length (replicate 0 x) = 0 length (replicate 0 x)     =      length [] replicate.1=      0 length.0                                   - -   3 P.I.V.    für n=k gilt    length (replicate k x) = n       - -   3 P.Induktionsschritt:   n = k+1                                                           ?length (replicate (k+1) x)  =  (k+1) length ( replicate (k+1) x )     =     length ( x: replicate k x ) replicate.2                                             =     1 + length ( replicate k x ) length.2                                             =    1 + k I.V.                                             =    k + 1 !   length ( replicate n x) = n   !   - -   6 P.⇒∀n∈!ProInformatik II, M. Esponda                                                                                                           !8
Klausur am 20. Februar 20178. Aufgabe(7 Punkte)Definieren Sie eine λ-Funktion IN, die überprüft, ob ein Element in einer Liste vorhanden ist.  Sie können dabei die Funktionen NIL (Testet, ob die Liste leer ist), = (Testet nach Gleichheit), HEAD, TAIL, und Y (Fixpunkt-Operator) als gegeben verwenden.  Die Funktionen für die Wahrheitswerte F und T müssen Sie selber definierenLösung: T              - -   1 P. F              - -   1 P. IN            - -   5 P.9. Aufgabe(15 Punkte)a)(2 P.)Was ist ein Kombinator? b)(3 P.)Schreiben Sie die I, K und S - Kombinatoren als Lambda-Ausdrücke.c)(4 P.) Reduzieren Sie folgenden Kombinatoren-Ausdruck zur Normalform. Begründen Sie die einzelnen Schritte. SI(KIS)(SKI)c) (6 P.) Zeigen Sie, dass folgende Lambda- und Kombinatoren-Ausdrücke äquivalent sind. 
