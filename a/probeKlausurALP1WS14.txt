Probeklausur: Funktionale Programmierung im WS 2014/151) Um es als echten Test zur Klausurvorbereitung zu nutzen, sollte man die Aufgabenin 90 Minuten bearbeiten ohne sie sich vorher angesehen zu haben.2) Man sollte auch nur die Hilfsmittel einsetzen, die in der Klausur erlaubt sein werden,n ̈amlich  eineinseitig, handschriftlichgef ̈ulltes  A4-Blatt  mit  Fakten  und  Formelneigener Wahl.3) Alle L ̈osungen sind kurz (stichpunktartig), aber inhaltlich ausreichend zu kommen-tieren!Aufgabe 1:Algebraische Typen8PunkteGegeben ist der folgende Datentyp f ̈ur (unechte) Bin ̈arb ̈aume mitInt-Markierungen:data Baum = Nil | Node Int Baum Bauma)  Definieren  Sie  eine  FunktiondeepestNeg::Baum->Intwelche  die  maximale  Tiefeeines  Knotens  mit  negativer  Markierung  bestimmt,  wobei  das  Ergebnis-1sein  soll,wenn kein Knoten eine negative Markierung hat.b) Definieren Sie eine FunktionhighestSingle::Baum->Intwelche die minimale Tiefeeines Knotens bestimmt, dessen Elternknoten nur ein Kind hat (das zweite ist ein Nil),wobei das Ergebnis0sein soll, wenn es keinen solchen Knoten gibt.c) Definieren Sie eine FunktionbiggestJump::Baum->Int, welche die gr ̈oßte Differenzaus den Markierungen eines Knotensvund eines Nachfahrens vonvbestimmt, wobeidas Ergebnis0sein soll, wenn der Baum nur aus der Wurzel besteht.Achtung:  Auch die Enkel und Urenkel geh ̈oren zu den Nachfahren!d) Analysieren Sie die Laufzeit vonbiggestJumpf ̈ur B ̈aume mitnKnoten in der FormΘ(f(n)).Aufgabe 2:Strukturelle Induktion6PunkteGegeben  sind  die  Funktioneng n m = n*n+mundsquare n = n*nsowie  die  be-kannten Definitionenmap f [ ]         = [ ]                      -- (1)map f (x:xs)      = f x :  map f xs          -- (2)foldr f e [ ]     = e                        -- (3)foldr f e (x:xs)  = f x (foldr f e xs)       -- (4)sum xs            = foldr (+) 0 xs           -- (5)Beweisen Sie, dass f ̈ur beliebigeInt-Listenxsdie Identit ̈atsum(map square xs)=foldr g 0 xsgilt.Aufgabe 3:Lazy evaluation3 + 3Punkte +3ZusatzpunkteBetrachten Sie die FunktionenfstCommon1, fstCommon2::[Int]->[Int]->[Int]->IntmitfstCommon1 xs ys zs = head[x|x<-[x|x<-xs,y<-ys,x==y],z<-zs,x==z]fstCommon2 xs ys zs = head[x|x<-[x|x<-xs, elem x ys],z<-zs,x==z]elem x [ ] = Falseelem x (y:ys) = (x==y) || elem x ysa) Wie viele Vergleichsschritte erfordert die Auswertung von1
fstCommon1 [1..10] [2..10] [3..10]?  (mit kurzer Begr ̈undung)b) Analysieren Sie die (worst case) Laufzeit vonfstCommon1f ̈ur drei Listen, die jew-eils die L ̈angenhaben.  Gefragt sind obere und untere Schranken,  also m ̈oglicht eineFunktion der Form Θ(f(n)).c)  Zusatzaufgabe:  Analysieren  Sie  die  (worst  case)  Laufzeit  vonfstCommon2f ̈ur  dreiListen, die jeweils die L ̈angenhaben (auch hier ein Θ(f(n))).Aufgabe 4:Typbestimmung3 + 3PunkteBestimmen Sie den allgemeist m ̈oglichen Typ f ̈ur die folgenden Ausdr ̈ucke und begr ̈undenSie kurz Ihre Antworten:a)f x y z = head [(s,t) | s <- x, t <- (y:x), 2*t == s, z s ]b)g  x y z|x == [y]   = z|otherwise  = x:zAufgabe 5:λ-Kalk ̈ul2 + 4Punktea)  Bestimmen  sie  f ̈ur  denλ-AusdruckE=  (λxy.xy z)(λx.xy)(λz.z x)  die  MengenFV(E)  undBV(E)  und  zeigen  Sie  f ̈ur  jedeS  Auftreten  von  Variablen  inEan,  obsie inEfrei oder gebunden sind.b) Reduzieren Sie den Ausdruck so weit wie m ̈oglich.Aufgabe 6:Codierungen4PunkteWelcher der folgenden CodesC1,C2,C3⊆{0,1,2}∗ist eindeutig decodierbar und welchernicht ?  (mit kurzer Begr ̈undung!)C1={01,012,0111,10,210}C2={01,02,10,210}C3={01,0122,10,210}
