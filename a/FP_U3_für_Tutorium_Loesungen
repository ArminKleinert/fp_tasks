Ziel: Auseinandersetzung mit polymorphe Funktionen, Listengeneratoren und Funktionen höherer Ordnung.1.Aufgabe (4 Punkte)Betrachten Sie folgende Funktionsdefinition, die die Menge aller möglichen Sublisten der Elemente einer Liste berechnet: powerList [] = [[]] powerList (x:xs) = powerList xs ++ map (x:) (powerList xs) Schreiben Sie alle Reduktionsschritte für den folgenden Ausdruck:         powerList  [1, 2, 3, 4] Losung: powerList [1, 2, 3, 4]   => powerList [2,3,4] ++ map (1:) (powerList [2,3,4]) => (powerList [3,4] ++ map (2:) (powerList [3,4]))         ++ map (1:) (powerList [3,4] ++ map (2:) (powerList [3,4])) => ((powerList [4] ++ map (3:) (powerList [4]))         ++ map (2:) ((powerList [4] ++ map (3:) (powerList [4]))))         ++ map (1:) ((powerList [4] ++ map (3:) (powerList [4]))          ++ map (2:) ((powerList [4] ++ map (3:) (powerList [4])))) => ((powerList [] ++ map (4:) (powerList []))                              ++ map (3:) (powerList [] ++ map (4:) (powerList []))                             ++ map (2:) (((powerList [] ++ map (4:) (powerList [])                              ++ map (3:) (powerList [] ++ map (4:) (powerList []))))                             ++ map (1:) (((powerList [] ++ map (4:) (powerList [])                              ++ map (3:) (powerList [] ++ map (4:) (powerList []))                              ++ map (2:) (((powerList [] ++ map (4:) (powerList [])                              ++ map (3:) (powerList [] ++ map (4:) (powerList []))))) => (( [[]] ++ map (4:) ( [[]] ))                              ++ map (3:) ( [[]] ++ map (4:) ( [[]] ))                             ++ map (2:) ((( [[]] ++ map (4:) ( [[]] )                              ++ map (3:) ( [[]] ++ map (4:) ( [[]] ))))                             ++ map (1:) ((( [[]] ++ map (4:) ( [[]] )                              ++ map (3:) ( [[]] ++ map (4:) ( [[]] ))                              ++ map (2:) ((( [[]] ++ map (4:) ( [[]] )                              ++ map (3:) ( [[]] ++ map (4:) ( [[]] ))))) Seite  von 13WiSe 2020/2021 Funktionale Programmierung 3. Übungsblatt (für das Tutorium) Prof. Dr. Margarita Esponda
=> ([[], [4]] ++ map (3:) ([[], [4]]) ++ map (2:) ((([[], [4]] ++ map (3:) ([[], [4]] )))                    ++ map (1:) ((([[], [4]] ++ map (3:) ([[], [4]]) ++ map (2:) ((([[], [4]]                     ++ map (3:) ( [[], [4]] )))) => [[], [4], [3], [3, 4]] ++ [[2], [2, 4], [2, 3], [2, 3,4]]                        ++ [[1], [1, 4], [1, 3], [1, 3, 4], [1, 2], [1, 2, 4], [1, 2, 3], [1, 2, 3, 4]] => [[], [4], [3], [3, 4], [2], [2, 4], [2, 3], [2, 3, 4], [1], [1, 4], [1, 3],                              [1, 3, 4], [1, 2], [1, 2, 4], [1, 2, 3], [1, 2, 3, 4]] 2. Aufgabe(2 Punkte)Was ist die Normalform folgendes Ausdrucks? Berechnen Sie die Lösung ohne den Ausdruck in dem Haskell-Interpreter einzugeben. Begründen Sie Ihre Lösung. [if x==y then 'o' else '.' | x <- [1..5], y <- [1..7], (x+y)<9] Seite  von 23if x==y then ‘o’ else ‘.’xy(x+y)<9“o"‘o'11True“o.”‘.’12True“o..”‘.’13True“o...”‘.’14True“o....”‘.’15True“o.....”‘.’16True“o......”‘.’17True“o.......”‘.’21True“o.......o”‘o’22True“o.......o.”‘.’23True“o.......o..”‘.’24True“o.......o...”‘.’25True“o.......o....”‘.’26True“o.......o....”27False“o.......o.....”‘.’31True“o.......o......”‘.’32True“o.......o......o”‘o' 33True“o.......o......o.”‘.’34Trueif x==y then ‘o’ else ‘.’xy(x+y)<9“o.......o......o..”‘.’35True“o.......o......o..”36False“o.......o......o..”37False“o.......o......o...”‘.’41True“o.......o......o....”‘.’42True“o.......o......o.....”‘.’43True“o.......o......o.....o”‘o' 44True45False46False47False“o.......o......o.....o.”‘.’51True“o.......o......o.....o..”‘.’52True“o.......o......o.....o...”‘.’53True54False“o.......o......o.....o...o”‘o' 55True56False57False
3.Aufgabe (7 Punkte)Definieren Sie eine polymorphe Funktion poss, die die Positionen eines Elements innerhalb einer Liste wiederum in einer Liste zurückgibt.  Anwendungsbeispiel:poss  'e'  "Freie Universität Berlin"  =>  [2, 4, 10, 19] a)Definieren Sie zuerst die Funktion nur unter Verwendung von expliziter Rekursion und Akkumulator-Technik. Lösung: poss :: Eq a => a -> [a] -> [Int] poss a xs = poss' [] 0 a xs             where poss' ps _ _ [] = ps             poss' ps n a (x:xs) | a==x = poss' (n:ps) (n+1) a xs                                         | otherwise = poss' ps (n+1) a xsb)Definieren Sie die Funktion unter sinnvoller Verwendung von Listengeneratoren und Funktionen höherer Ordnung. Losung:poss:: Eq a => a -> [a] -> [Int]poss a xs = [ fst (n,x) | (n,x) <- zip [0..] xs, a==x]
