
1  18.02.2020Funktionale Programmierung   WS 2019/2020 Prof. Dr. Margarita Esponda KlausurName:  ........................................................   Vorname:  ......................................................Matrikel-Nr: ......................................Wichtige Hinweise: 1)Schreiben Sie in allen Funktionen die entsprechende Signatur.  2)Verwenden Sie die vorgegebenen Funktionsnamen, falls diese angegeben werden. 3)Die Klausur muss geheftet bleiben. 4)Schreiben Sie Ihre Antworten in den dafür vorgegebenen freien Platz, der unmittelbar nach der Frage steht. 5)Keine Hilfsmittel sind erlaubt. 6)Die maximale Punktzahl ist 100. Viel Erfolg!KlausurAufgabeA1A2A3A4A5A6A7A8A9SummeNoteMax. Punkte109712128121614100Punkte
2  18.02.20201. Aufgabe (10 Punkte)a)(6 P.) Welche Auswertungsstrategie wird in der Haskell-Programmiersprache verwendet? Erläutern Sie die Auswertungsstrategie anhand eines Beispiels. Welche Vorteile hat eine funktionale Programmiersprache damit? b)(4 P.) Was ist ein statisches Typsystem im Kontext von Programmiersprachen? Welche Vorteile hat eine Programmiersprache damit?Lösung: a)Nach Bedarf (Lazy-evaluation)                                                         - -         1P.- -         3P.       Vorteile: •Wenn eine Normalform existiert, wird diese erreicht.                     - -         2P. b)Der Datentyp der Funktionen wird statisch während der Übersetzungszeit des Programms abgeleitet.                                                                    - -         2P. Vorteile: •Datentyp-Fehler werden früher erkannt •durch die Reduzierung der Typ-Überprüfungreduziert sich die Ausführungszeit •Typ-Ableitung (Typ-Inferenz) ist möglich- -         2P. Klausur
3  18.02.20202. Aufgabe (9 Punkte)Betrachten Sie folgende Funktionsdefinition: com :: (a -> a) -> (a -> a) -> a -> (a, a) com f g x = ((f .g) x, (g .f) x) Reduzieren Sie folgenden Ausdruck schrittweise zur Normalform: a)  com (* 10) (mod 10) 7Lösung:   com (* 10)  (mod 10) 7             => ( (* 10). (mod 10) ) 7,  ( (mod 10). (* 10) ) 7=> ( (* 10)((mod 10) 7),  ( (mod 10)((* 10) 7)=> ( (* 10)(3),  ( (mod 10)70 ) - -  4 P.=> (30,  10)- -  1 P.b) foldl (\ys x-> x:ys) [] (take 4 [1..]) Lösung:    =>   (foldl (\ys x-> x:ys) []  [1,2,3, 4]     =>   (foldl (\ys x-> x:ys) 1:[]  [2,3, 4]     =>   (foldl (\ys x-> x:ys) 2:[1]  [3, 4]     =>   (foldl (\ys x-> x:ys) 3:[2,1]  [4]     =>   (foldl (\ys x-> x:ys) 4:[3,2,1]  []     =>   (foldl (\ys x-> x:ys) [4,3,2,1]  []                                           - -  3 P.    =>   [4, 3,2,1]                                                                            - -  1 P.Klausur
4  18.02.20203. Aufgabe (7 Punkte)Schreiben Sie eine Funktion, die mit Hilfe einer endrekursiven Funktion die Fibonacci- Zahlen mit linearem Aufwand berechnet. Lösung 1): fib: Integer -> Integer - - 1 P.fib n = quickFib  01  n      - - 1 P.where                    quickFib a  b  0  = a - - 1 P.                    quickFib a  b  n  = quickFib b (a+b) (n-1) - - 4 P.Lösung 2): nextFib :: (Integer, Integer) -> (Integer, Integer)  - - 1 P.nextFib  (a,b)  =  (b, a+b)   - - 1 P.fibTuple n | n==0           =  (0, 1)  - - 1 P.                 | otherwise   =  nextFib (fibTuple (n-1))  - - 3 P.fib n = fst ( fibTuple n )  - - 1 P.4. Aufgabe(12 Punkte)Betrachten Sie folgendes Anwendungsbeispiel der currifiziertenzipWith Standardfunktion von Haskell:                    zipWith (^) [1, 2, 3] [2, 3, 4] => [1, 8, 81] a)(6 P.) Definieren Sie eine polimorphe uncurrifizierte Version der zipWith Funktion. b)(6 P.) Schreiben Sie eine sinnvolle Definition der zipWith Funktion mit Hilfe von Listengeneratoren. Sie dürfen dabei andere Standardfunktionen von Haskell verwenden.Lösungen a), b): zipWith_b :: ((a -> b -> c), [a], [b]) -> [c] - -  1,5 P.zipWith_b (f, [], _) = [] zipWith_b (f, _, []) = [] - -  1,5 P.zipWith_b (f, (x:xs), (y:ys)) = (f x y): zipWith_b (f, xs, ys)       - -  3 P.zipWith_a ::(a -> b -> c) -> [a] -> [b] -> [c] - -  1 P.zipWith_a  f  xs  ys = [ f a b | (a,b) <- zip xs ys ]  - -  5 P.Klausur
5  18.02.20205. Aufgabe(12 Punkte)Betrachten Sie folgende algebraische Datentypen und Funktionen: data  Nat  =  Zero  | S Nat  deriving Show data  ZInt =  Z Nat Nat  deriving Show data  B  =  T | F   deriving Show add ::  Nat-> Nat-> Nat add a  Zero = a add a  (S b) = add (S a) b   mult :: Nat -> Nat -> Nat   mult  _ Zero  = Zero   mult  a (S b) = add a (mult a b) foldn :: (Nat -> Nat) -> Nat -> Nat -> Nat foldn  h  c  Zero  = c foldn  h  c  (S n) = h (foldn  h  c  n) a) Definieren Sie damit die xor, smaller (<)und equal (==) Funktionen für den Datentyp B und Nat. Lösung:      xor :: B -> B -> B    xor T  T  =  F     xor F  F  =  F      xor T  F  = T       xor F  T  = F - -  2 P.smaller :: Nat -> Nat -> B smaller Zero (S _) = T smaller (S a) (S b) = smaller a b smaller _ _ = F- -  3 P.equal :: Nat -> Nat -> B equal Zero Zero = T equal (S a) (S b) = equal a b equal _ _ = F- -  3 P.b) Definieren Sie die Potenzfunktion power für den Datentyp Nat (natürliche Zahlen) unter Verwendung der foldn Funktion.      Lösung: power :: Nat -> Nat -> Nat  power Zero Zero = error  "undefined"  power m = foldn (mult m) (S Zero) - -  4 P.Klausur
6  18.02.20206. Aufgabe (8 Punkte)Betrachten Sie folgenden algebraischen Datentyp für einfache binäre Bäume: dataSimpleBT  =  L | N  SimpleBT  SimpleBTDefinieren Sie damit folgende Funktionen:  height :: SimpleBT -> Integer      - - berechnet die Höhe des Baumesbalanced :: SimpleBT -> Bool      - - entscheidet, ob der Baum vollständig- - bzw. balanciert ist oder nicht.Wenn Sie dafür zusätzliche Funktionen brauchen, müssen Sie diese auch definieren. Lösung: height :: SimpleBT -> Integer height L = 0 height (N lt rt) = (max (height lt) (height rt)) + 1   - - 4 P.balanced :: SimpleBT -> Bool balanced  L = True balanced  (N lt rt) = (balanced lt) && (balanced rt) && height lt == height rt - -  4 P. 2. Lösung: size :: SimpleBT -> Integer size L = 1 size (N lt rt) = size lt + size rt + 1 balanced :: SimpleBT -> Bool balanced L = True balanced (N lt rt) = (balanced lt) && (balanced rt) && size lt == size rt 3. Lösung: height :: SimpleBT -> Integer height L = 0 height (N lt rt) = (max (height lt) (height rt)) + 1 size :: SimpleBT -> Integer size L = 1 size (N lt rt) = size lt + size rt + 1 balanced :: SimpleBT -> Bool balanced  tree  =  (size tree) == (2^((height tree)+1)-1) Klausur
7  18.02.20204. Lösung: balanced :: SimpleBT -> Bool balanced tree = fst (balanced’ tree)                  where                  balanced’ L = (True, 1)                  balanced’ (N lt rt) = (bLeft && bRight && dLeft == dRight, 1+dRight)                                               where                                                   (bLeft,   dLeft  ) = balanced’ lt                                                   (bRight, dRight) = balanced’ rt Klausur
7. Aufgabe (12 Punkte)Betrachten Sie folgenden algebraischen Datentyp mit entsprechenden Funktionsdefinitionen: data Tree a = Leaf a | Node (Tree a) (Tree a)       size :: Tree a -> Int     size (Leaf _ ) = 1                             ...................................... size.1 size (Node lt rt) = size rt + size lt      ....................................... size.2 depth :: Tree a -> Int depth (Leaf _ ) = 1                         ....................................... depth.1 depth (Node lt rt) = max (depth lt) (depth rt) + 1 ........... depth.2 Beweisen Sie mit Hilfe von struktureller Induktion, dass folgende Eigenschaft gilt:Lösung: Induktionsanfang: t = (Leaf _)      ?                      size (Leaf _) <= 2depth (Leaf _)size (Leaf _)  =size.1 1      <=algebra 21    =depth.1 2depth (Leaf _) - -  3 P.Induktionsvoraussetzung:    für t = Node  lt  rt   giltI.V. size lt <= 2depth ltsize rt <= 2depth rt- -  1 P.Induktionsschritt:    t = Node lt rt           ?  size (Node lt rt) <= 2depth (Node lt rt)size (Node lt rt) =size.2 size lt  +  size rt    <=I.V. 2depth lt+2depth rt                                                                            < =algebra 2*2max(depth lt, depth rt)                                   =algebra2max(depth lt, depth rt) + 1=depth.2 2depth (Node lt rt)damit ist     size (Node lt rt)<= 2depth (Node lt rt)     bewiesen.+Die Behauptung gilt dann für alle t endlichen Bäume.                           - -  8 P.Klausursizet≤2deptht
9  18.02.20208. Aufgabe(16 Punkte)a) Reduzieren Sie den folgenden Lambda-Ausdruck zur Normalform:Lösung:- -             (5 P.)b) Schreiben Sie einen Lambda-Ausdruck, der die Subtraktion von zwei natürlichenZahlen berechnet. Sie können dabei die Funktion P (Vorgänger) als gegeben verwenden. Lösung:- - (1 P.)c) Definieren Sie einen Lambda-Ausdruck, der die GGT-Funktion von Euclid (größter gemeinsamer Teiler von zwei positiven natürlichen Zahlen) berechnet.  ggt p q | p==q = p             | p>q   = ggt (p-q) q             | p<q   = ggt p (q-p) Sie können dabei die Funktionen CSUB (Subtraktion für natürliche Zahlen), Y (Fixpunkt-Operator) und die Vergleichsoperationen <, >, = als gegeben verwenden. Lösung:- - (5 P.)Klausur(λxy.xy(λxy.y))(λxy.x)(λxy.y)(λxy.xy(λxy.y))(λxy.x)(λxy.y)⇒β(λy.(λxy.x)y(λxy.y))(λxy.y)⇒β(λxy.x)(λxy.y)(λxy.y)⇒β(λy.(λxy.y))(λxy.y)⇒β(λxy.y)≡F(λnm.m(P(n))GGT≡Y(λrpq.=pqp(>pq(r({CSUB}pq)q)(rp({CSUB}qp))))
10  18.02.2020c) Zeigen Sie, dass folgende Lambda- und Kombinatoren-Ausdrücke äquivalent sind.  1.Lösung:- -  (5 P. 2.Lösung: oder- -  (5 P.)λx.λy.(xx)≡S(KK)(SII)(λx.λy.(xx))ab⇒(λy.(aa))b⇒aaS(KK)(SII)ab⇒(KK)a((SII)a)b⇒K((SII)a)b⇒(SII)a⇒Ia(Ia)⇒aaKlausurTλx.λy.(xx)[]⇒5Tλx.Tλy.(xx)[]⎡⎣⎤⎦⇒3Tλx.KTxx[]⎡⎣⎤⎦⇒6,1Tλx.K(xx)[]⇒4ST(λx.K)[]T(λx.xx)[]⇒3S(KK)T(λx.xx)[]⇒4S(KK)(ST(λx.x)[]T(λx.x)[])⇒2,2S(KK)(SII)72,26462,84
11  18.02.20209. Aufgabe (14 Punkte) a) Zeigen Sie, dass die Funktion half, die eine natürliche Zahl durch zwei teilt (ganzzahlige Division) primitiv rekursiv ist. Das bedeutet, wenn Sie für die Definition andere Hilfsfunktionen verwenden, müssen Sie auch zeigen, dass diese Hilfsfunktionen primitiv rekursiv definierbar sind. b) Definieren Sie zusätzlich Ihre Funktionen unter Verwendung der in der Vorlesung definierten z, s, p, compose und pr Haskell-Funktionen. Lösung a):  - - (7 P.)Lösung b):   - - (7 P.)isZero :: PRFunction isZero  = pr isZero (const 1) (const 0)  add :: PRFunction        add  = pr add (p 1) (compose s [(p 1)]) not :: PRFunction not  = isZero odd :: PRFunction odd [n] = pr odd (const 0) (compose not [(p 1)]) [n] half :: PRFunction half [n] = pr half (const 0) (compose add [(p 1),(compose odd [(p 2)])]) [n] KlausurisZero(0)=C10isZero(S(n))=Z(isZero(n),n)add(0,m)=π11(m)add(S(n),m)=S(π13(add(n,m),n,m))not=isZeroodd(0)=C00odd(S(n))=not(π12(odd(n),n))half(0)=C00half(S(n))=add(π12(half(n),n),odd(π22(half(n),n)))
12  18.02.2020-- Null-Funktionz  :: [Integer] -> Integerz xs = 0-- Nachfolger-Funktions  :: [Integer] -> Integers [x] = x+1-- Projektions-Funktionenp :: Integer -> [Integer] -> Integerp 1 (a:b) = ap n (a:b) = p (n-1) b typePRFunction  =  ( [Integer] →Integer ) --Kompositionsschemacompose :: PRFunction -> [PRFunction] -> [Integer] -> Integercompose  f  gs  xs  =  f  [ g  xs | g <- gs ]--Rekursionsschemapr :: PRFunction -> PRFunction -> PRFunction -> [Integer] -> Integerpr  rec  g  h  (    0  :xs)  =  g  xspr  rec  g  h  ((n+1):xs) =  h ( (rec (n:xs)):n:xs )Transformationsregeln,um Lambda-Terme in SKI-Terme zu verwandeln.1)  T[x]             => x  2)  T[(E1 E2)]    => (T[E1] T[E2]) 3)  T[λx.x]  => I4)T[λx.E]  => (K T[E])                       wenn x∉FV(E) 5)T[λx.E x]        => (T[E])                          wenn x∉FV(E)  6)  T[λx.(E1 E2)]   => (S T[λx.E1] T[λx.E2])     falls x∈FV(E1)  oder  x∈FV(E2) 7)  T[λx.λy.E]    => T[λx.T[λy.E]]                falls x∈FV(E) Transformations- bzw. EliminierungsregelnKlausur0)T[x]⇒xT[I]⇒IT[K]⇒KT[S]⇒S1)T[E1E2]⇒T[E1]T[E2]2)T[λx.E]⇒elim.x[E]3)elim.x[x]⇒I4)elim.x[y]⇒Kywennx≠yelim.x[I]⇒KIelim.x[K]⇒KKelim.x[S]⇒KS5)elim.x[λy.E]⇒elim.x[elim.y[E]]6)elim.x[Ex]⇒T[E]wennx∉FV(E)7)elim.x[E1E2]⇒S(elim.x[E1])(elim.x[E2])
