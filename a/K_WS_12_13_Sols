1. Aufgabe (12 Punkte)a)Was verstehen Sie unter dem Begriff Referentielle Transparenz?Mögliche Lösungen:-Eine Funktion liefert immer bei gleicher Eingabe das gleiche Ergebnis.-Der Wert eines Ausdrucks hängt nur von den Werten der aktuellen Parameter ab.-Keine Seiteneffekte.b)Definieren Sie eine uncurrifizierte Version der map-Funktion.Lösung:map :: (a -> b) -> [a] -> [b]map  (_, [])     =  []               map  (f, (x:xs)) =  f x : map (f, xs)c)Was ist ein statisches Typsystem im Kontext von Programmiersprachen?Lösung:Der Datentyp der Funktionen wird statisch während der Übersetzungszeit des Programms abgeleitet.Es findet eine statische Bindung der Datentyp der Funktionen auf Grund von explizite Deklarationen oder Typinferenz.Nachdem der Datentyp einer Funktion oder Ausdruck festgelegt wird, kann keine Veränderung mehr statt finden.d)Definieren Sie eine möglichst einfache Funktion, die nach mindestens einem ihrer Argumente strikt ist. Erläutern Sie kurz Ihre Antwort.Lösung:   add a b = a + b                 Begründung:      add⊥b=⊥       oderadda⊥=⊥2. Aufgabe (32 Punkte)a) Definieren Sie einen (\\)-Operator, der aus einer Liste xs alle Elemente, die sich in der Liste ys befinden, entfernt.Lösung:(\\) :: (Eq a) => [a] -> [a] -> [a](\\) [] ys = [](\\) (a:xs) ys | elem a ys   = (\\) xs ys                    | otherwise   = a:(\\) xs ys11.02.2013ALP1 Endklausur
2b) Programmieren Sie mit Hilfe Ihres (\\)-Operators eine Funktion, die aus einer beliebigen Liste natürlicher Zahlen die kleinste natürliche Zahl findet, die nicht in der Liste vorkommt.Anwendungsbeispiel:  firstNatNotIn [2, 0, 1, 8, 9, 12, 6]  =>  3Lösung:firstNatNotIn :: [Integer] -> IntegerfirstNatNotIn xs = head ([0..] \\ xs)c) Was ist die Komplexität der Funktionen in a) und b)? Erläutern Sie Ihre Antwort.Lösung:a)   O(n2)  +  Begründung ...b)   O(n2)  +  Begründung ...3. Aufgabe (6 Punkte)Die freq-Funktion berechnet, wie oft ein angegebenes Element in einer Liste vorkommt. Anwendungsbeispiele: freq  3  [2, 1, 4, 8, 9, 3, 3, 0] => 2freq  'a'  "abcdea abda" => 4Schreiben Sie eine Definition der freq-Funktion, in der nur die foldl-Funktion und eine anonyme Funktion verwendet wird.Lösung:freq :: (Eq a) => a -> [a] -> Integerfreq a  = foldl (\x y -> if (y==a) then x+1 else x) 04. Aufgabe (20 Punkte)Betrachten Sie folgende Funktionsdefinitionen:          (.)  ::  (b -> c) -> (a -> b) -> a -> c(.)  f  g  a  =  f (g  a)                                   -----------------   (.) .1filter :: (a -> Bool) -> [a] -> [a]filter p []         =  []               ----------------   filter.1filter p (x:xs)  | p x          =  x:filter p xs             ----------------   filter.2                     | otherwise =  filter p xs       ----------------   filter.3map :: (a -> b) -> [a] -> [b]map  _  []        =  []                                  ----------------   map.1map  f  (x:xs)   =  f x : map f xs      ----------------   map.2Zeigen Sie mittels struktureller Induktion über Listen, dass für jede endliche Liste xsgilt:(filter p) . (map f) = (map f) . (filter (p . f))11.02.2013ALP1 Endklausur
3Lösung:Zuerst zeigen wir die Eigenschaft für die leere Liste [].(filterp)⋅(mapf)[]=(.).1filterp(mapf[])=map.1filterp[]=filter.1[]=map.1mapf[]=filter.1mapf(filter(p.f)[])=(.).1(mapf)⋅(filter(p.f))[]I.V: Die Eigenschaft gilt für eine beliebige Liste der Länge n.(filterp).(mapf)xs=(mapf).(filter(p.f))xsZur zeigen ist: (filterp).(mapf) (x:xs)=(mapf).(filter(p.f)) (x:xs)mit x irgendein Element mit geeigneten Datentyp:1.Fall  p (f x) = (p.f) x ist falsch (False)(filterp)⋅(mapf)(x:xs)=(.).1,map.2filterp((fx):mapxs)                                             =filter.3filterp(mapfxs)=(.).1(filterp)⋅(mapf)xs=I.V.(mapf)⋅(filter(p⋅f)xs)=(.).1mapf(filter(p⋅f)xs)=filter.3mapf(filter(p⋅f)(x:xs))=(.).1(mapf)⋅(filter(p⋅f))(x:xs)2. Fall  p (f x) = (p.f) x ist wahr (True)(filterp).(mapf)(x:xs)=(.).1filterp(fx:mapfxs)=filter.2fx:filterp(mapfxs)=(.).1fx:(filterp)⋅(mapf)xs=I.V.fx:(mapf)⋅(filter(p.f)xs)=(.).1fx:mapf(filter(p⋅f)xs)=map.2mapf(x:filter(p⋅f)(xs))=filter.2(mapf)⋅(filter(p⋅f))(x:xs)=(.).1(mapf)⋅(filter(p⋅f))(x:xs)11.02.2013KALP1 Endklausur
45. Aufgabe (18 Punkte)a) Reduzieren Sie den folgenden Lambda-Ausdruck zur Normalform:(λxy. xy(λxy. y))(λxy. x)(λxy. y)Lösung:(λxy. xy(λxy. y))(λxy. x)(λxy. y)⇒β(λy.(λxy. x)y(λxy.y))(λxy. y)⇒β(λxy. x)(λxy. y)(λxy.y)⇒β(λy.(λxy. y))(λxy.y)⇒β(λxy. y)≡Fb) Schreiben Sie einen Lambda-Ausdruck, der die Länge einer Liste berechnet. Sie können dabei die Funktionen S(Nachfolger), NIL(Test ob leere Liste),  TAIL und Y(Fixpunkt-Operator) als gegeben verwenden.Lösung:Y(λrl.NIL{}l0(S(r(TAIL{}l))))b) Zeigen Sie, dass folgende Lambda- und Kombinatoren-Ausdrücke äquivalent sind. λx.λy.(xx)≡S(KK)(SII)1.Lösung:Tλx.λy.(xx)[]⇒5Tλx.Tλy.(xx)[]⎡⎣⎤⎦⇒3Tλx.KTxx[]⎡⎣⎤⎦⇒6,1Tλx.K(xx)[]⇒4ST(λx.K)[]T(λx.xx)[]⇒3S(KK)T(λx.xx)[]⇒4S(KK)(ST(λx.x)[]T(λx.x)[])⇒2,2S(KK)(SII)11.02.2013KALP1 Endklausur
52.Lösung:λx.λy.(xx)ab⇒λy.(aa)b⇒aaS(KK)(SII)ab⇒(KK)a((SII)a)b⇒K((SII)a)b⇒(SII)a⇒Ia(Ia)⇒aa6. Aufgabe (12 Punkte)Zeigen Sie, dass die Funktion gerade, die entscheiden kann, ob eine natürliche Zahl gerade ist oder nicht, primitiv rekursiv ist, indem Sie diese nur unter Verwendung von primitiv rekursiven Funktionen definieren. Das bedeutet, wenn Sie für die Definition andere Hilfsfunktionen verwenden, müssen Sie auch zeigen, dass diese primitiv rekursiv definierbar sind.Lösung:equalZero(0)=   (SZ)()oder=  C10equalZero(S(n))=Z(equalZero(n),n)equalZero=notgerade(0)= (SZ)()oder=C10gerade(S(n))=not(π12(gerade(n),n))Transformationsregeln,um Lambda-Terme in SKI-Terme zu verwandeln.1) T[x]     => x2) T[λx.x]  => I3) T[λx.E]  => (K T[E])              wenn x nicht frei in E ist4) T[λx.(E1 E2)]  => (S T[λx.E1] T[λx.E2]) 5) T[λx.λy.E]     => T[λx.T[λy.E]]                falls x frei in E ist6) T[(E1 E2)] => (T[E1] T[E2])
