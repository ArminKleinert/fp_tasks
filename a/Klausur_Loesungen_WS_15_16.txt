1. Aufgabe(8 Punkte)a) (2 P.) Was verstehen Sie unter statischer Typisierung im Kontext von Programmiersprachen?Der Datentyp der Funktionen wird statisch während der Übersetzungszeit des Programms abgeleitet. b) (2 P.) Nennen Sie die zwei wichtigsten Vorteile von statischen Typ-Systemen.•Datentyp-Fehler werden früher erkannt und nicht erst zur Laufzeit. •durch die Reduzierung der Typ-Überprüfungreduziert sich die Ausführungszeit. •Typ-Ableitung kann gemacht werden. (Typ-Inferenz).c) (4 P.) Erläutern Sie die Auswertungsstrategie nach Bedarf (Lazy-Evaluation). Welche Vorteile hat eine Programmiersprache, die diese Auswertungsstrategie verwendet?Lazy-evaluation ist eine optimierte Auswertungsvariante von call-by-name.  In der call-by-name Auswertungsstrategie werden Ausdrücke von außen nach innen ausgewertet. D.h. Argumente werden nur bei Bedarf reduziert. Der wichtigste Vorteil der Lazy-Evaluation ist, dass, wenn ein Ausdruck eine Normalform besitzt, diese immer erreicht wird.  Diese Art der Auswertung ist effizienter und terminiert immer, wenn eine Normalform existiert.AufgabeA1A2A3A4A5A6A7A8A9A10Max. SummeNoteMax. Punkte888108121481212100PunkteFunktionale Programmierung, M. Esponda
!2Klausur am 15. Februar 20162. Aufgabe(8 Punkte)Reduzieren Sie folgende zwei Haskell-Ausdrücke zur Normalform. Schreiben Sie mindestens drei Reduktionsschritte auf oder begründen Sie Ihre Antwort.  a)length [(x,y) | x<-[1..5], y<-[5,4..1], x>y]b)((foldr (+) 5).(map (\x -> div x 3))) [1..8]a)  =>    length [(x,y) | x<- [1,2,3,4,5], y<-[5,4,3,2,1], x>y] =>    length [(2,1), (3,2), (3,1), (4,3), (4,2), (4,1), (5,4), (5,3), (5,2), (5,1)] =>    10 b) =>    ((foldr (+) 5).(map (\x -> div x 3))) [1,2,3,4,5,6,7,8]=>    (foldr (+) 5) ((map (\x -> div x 3)) [1,2,3,4,5,6,7,8]) =>    (foldr (+) 5) [0, 0, 1, 1, 1, 2, 2, 2]) =>    14 3. Aufgabe(8 Punkte)Betrachten Sie folgende Funktionsdefinition, die eine beliebig lange Liste von Primzahlen berechnet:primes = sieb [2..] where sieb (p:xs) = p:sieb[k | k<-xs, (mod k p)>0] Programmieren Sie damit eine primeOne Funktion, die die ersten n Primzahlen berechnet, die mit der Ziffer 1 enden.       Anwendungsbeispiel:    primeOne  6  =>  [11, 31, 41, 61, 71, 101] Lösung: primeOne :: Int -> [Integer]      primeOne n = take n [x|x<-primes, (mod x 10)==1]Funktionale Programmierung, M. Esponda
!3Klausur am 15. Februar 20164. Aufgabe(10 Punkte)Betrachten Sie folgende max1 und max2 Funktionsdefinitionen, die das größte Element einer Liste berechnen.max1 [x]   = x max1 (x:xs) | all (<=x) xs = x                     | otherwise    = max1 xs all p xs = foldl (&&) True (map p xs) max2 [x] = x max2 (a:b:xs) = aux a (b:xs) where  aux a [] = a aux a (b:xs) | a>b = aux a xs                                                | otherwise = aux b xsAnalysieren Sie die Komplexität der max1 und max2 Funktionen.Funktionale Programmierung, M. Esponda
!4Klausur am 15. Februar 20165. Aufgabe(8 Punkte)Betrachten Sie folgenden algebraischen Datentyp und folgende Funktionsdefinition:data Nat = Zero | S Nat deriving Showadd ::  Nat -> Nat -> Nat add a Zero = a add a (S b) = add (S a) bDefinieren Sie damit folgende Funktionen: gerade :: Nat -> Bool fibonacci :: Nat -> Nat Lösung: gerade Zero         = True gerade (S (S a))   = gerade a gerade  _             = False fibonacci Zero = Zero fibonacci (S Zero) = S Zero fibonacci (S (S b)) = add  (fibonacci b) (fibonacci (S b))Funktionale Programmierung, M. Esponda
!5Klausur am 15. Februar 20166. Aufgabe(12 Punkte)Betrachten Sie folgenden algebraischen Datentyp für binäre Suchbäume:data BSearchTree a = Nil | Node a (BSearchTree a) (BSearchTree a) Definieren Sie eine Funktion complete, die einen Baum t als Argument bekommt und entscheidet, ob der Baum vollständig ist oder nicht.complete :: (Ord a) => BSearchTree a -> Bool-- 1. Lösung: height :: BSearchTree a -> Integer height Nil = 0 height (Node x lt rt) = (max (height lt) (height rt)) + 1 complete Nil = True complete (Node x lt rt) = (complete lt) && (complete rt) && height lt == height rt -- 2. Lösung: size :: BSearchTree a -> Integer size Nil = 1 size (Node x lt rt) = size lt + size rt + 1 complete2 Nil = True complete2 (Node x lt rt) = (complete2 lt) && (complete2 rt) && size lt == size rt -- 3. Lösung: complete3 tree = (size tree) == (2^((height tree)+1)-1) -- 4. Lösung: complete4 tree = fst (balanced tree) where balanced Nil = (True, 1) balanced (Node x lt rt) = (bLeft && bRight && dLeft==dRight, 1+dRight)                                              where                                               (bLeft, dLeft) = balanced lt                                               (bRight, dRight) = balanced rtFunktionale Programmierung, M. Esponda
!6Klausur am 15. Februar 20167. Aufgabe(14 Punkte)Betrachten Sie folgende Funktionsdefinitionen: drop 0 xs = xs                             ............... (drop.1)drop (n+1) [] = []                            ............... (drop.2) drop (n+1) (x:xs)     = drop n xs       ............... (drop.3)take 0 xs = []                            ............... (take.1) take (n+1) [] = []                            ............... (take.2)take (n+1) (x:xs)     = x:(take n xs)  ............... (take.3)(++) [] ys = ys ............... ((++).1) (++) (x:xs) ys = x:(xs ++ ys)       ................ ((++).2)Beweisen Sie mittels struktureller Induktion über die Liste xs folgende Eigenschaft: take n xs ++ drop n xs  =  xsGeben Sie für alle Beweisschritte die verwendeten Beziehungen oder die Gesetze an.Lösung: I.A. xs = [] zz.take n [] ++ drop n []  = []     1.Fall. n=0zz.   take 0 [] ++ drop 0 []  = []  take 0 [] ++ drop 0 []     =     [] ++ []  take.1, drop.1            =   []    (++).1    2.Fall. n>0    zz.   take n [] ++ drop n []  = []  take n [] ++ drop n []     =     [] ++ []  take.2, drop.2            =   []    (++).1I.V.  für  xs = xs’  gilt take n xs’ ++ drop n xs’  =  xs’ Funktionale Programmierung, M. Esponda
!7Klausur am 15. Februar 2016Induktionsschritt.  xs = (x:xs’)zz.  take n (x:xs’) ++ drop n (x:xs’)  =  (x:xs’)   1. Fall. n=0 zz.  take 0 (x:xs’) ++ drop 0 (x:xs’)   =  (x:xs’)           take 0 (x:xs’) ++ drop 0 (x:xs’)  =  [] ++ (x:xs’) take.1, drop.1 =   (x:xs’) (++).1   2. Fall   n>0     take n (x:xs’) ++ drop n (x:xs’)   =   x:(take (n-1) xs’) ++ drop n (x:xs’) take.3 =   x:(take (n-1) xs’) ++ drop (n-1) xs’ drop.3=  x: ((take (n-1) xs’) ++ drop (n-1) xs’) (++).1= (x: xs’)   I.V dann gilt die Eigenschaft für alle xs :: a endliche Listen. 8. Aufgabe(8 Punkte)Definieren Sie eine λ-Funktion IN, die überprüft, ob ein Element in einer Liste vorhanden ist.  Sie können dabei die Funktionen NIL (Testet, ob die Liste leer ist), HEAD, TAIL, = und Y (Fixpunkt-Operator) als gegeben verwenden.  Die Funktionen für die Wahrheitswerte F und T müssen Sie selber definieren.Lösung: Funktionale Programmierung, M. EspondaIN=Y(λrxℓ.{NIL}ℓF(=x({HEAD}ℓ)T(rx({TAIL}ℓ))))T≡λx.λy.xF≡λx.λy.y
!8Klausur am 15. Februar 20169. Aufgabe(12 Punkte)a)(2 P.)Was ist ein Kombinator? Ein Kombinator ist eine primitive Funktion (Lambda-Ausdruck) ohne freie Variablen.b)(3 P.) Reduzieren Sie folgenden Kombinatoren-Ausdruck zur Normalform. Begründen Sie die einzelnen Schritte. Lösung:   SI(KIS)(SKI) =>SII(SKI)        => I(SKI)(I(SKI))         => (SKI)(SKI)                => K(SKI)(I(SKI))                => SKIc) (7 P.) Zeigen Sie, dass folgende Lambda- und Kombinatoren-Ausdrücke äquivalent sind.  
