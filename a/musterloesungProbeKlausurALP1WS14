
Funktionale Programmierung–WS 2014/15Musterl ̈osung zur 1. Klausur am 17.02.2015Die  nachfolgende  Musterl ̈osung  stellt  jeweils  nur  einen  von  m ̈oglicherweise  mehrerenL ̈osungswegen vor.  Die Kommentare sind bereits relativ kurz gefasst, aber man k ̈onntees aber noch weiter verk ̈urzen, indem Stichpunkte an Stelle von ganzen S ̈atzen verwendetwerden.  Passagen, an denen Ideen zum besseren Verst ̈andnis noch genauer beschriebenwerden, sind als Zusatzkommentar gekennzeichnet.  Solche Zusatzkommentare sind alsof ̈ur das Erreichen der vollen Punktzahl nicht relevant.Da ich  ̈ubesehen hatte, dass die Teilaufgaben 1.a und 1.b nur in der Vorlesung besprochenwurden, aber in den ̈Ubungen nicht vorkamen, wurden noch vier weitere Punkte (alsoinsgesamt  sieben)  als  Zusatzpunkte  deklariert.   Damit  reichen  jetzt  18  Punkte  zumBestehen der Klausur.Die erreichbaren Punkte sind bereits in der Kopfzeile der Aufgaben auf die einzelnenTeilaufgaben aufgegliedert worden.  Um die Feinverteilung der Punkte noch transpar-enter  zu  machen,  wird  bei  der  Musterl ̈osung  an  einigen  Stellen  angezeigt,  auf  welcheIdeen, Ans ̈atze und Teilschritte man bereits Punkte bekommen kann, wenn die L ̈osungder  Aufgabe  nicht  vollst ̈andig  erbracht  wurde.   Dabei  steht  das  Symbolf ̈ur  einenhalben und das Symbol•f ̈ur einen ganzen Punkt.1
Aufgabe 1:    Algebraische Typen und Typklassen2 + 1 + 1 + 3PunkteGegeben sind die folgenden Datentypen f ̈ur Variablen und arithmetische Ausdr ̈ucke:data Variable = U | V | W | X | Y | Z deriving Eq, Ord, Showdata Exp = Var Variable | Add Exp Exp | Mult Exp Expa) Definieren SieExpals Exemplar der KlasseShowwobei dieshowFunktion den Haskell-Ausdruck als  ̈ublichen arithmetischen Term wie z.B. (X∗(Y+Z)) darstellen soll.b) Definieren SieExpals Exemplar der KlasseEqwobei der Operator==alle Gleich-heiten ber ̈ucksichtigen soll, die sich aus Anwendungen des Kommutativgesetzes ergeben(Assoziativ-  und  Distributivgesetz  sollen  nicht  ber ̈ucksichtigt  werden),  d.h.    f ̈ur  dieAusdr ̈ucke  der  Terme  (X∗(Y+Z))  und  ((Z+Y)∗X)  soll  Gleichheit  und  f ̈ur  dieAusdr ̈ucke der Terme (X+ (Y+Z)) und ((X+Y) +Z) soll Ungleichheit gelten.c) Definieren Sie eine Funktioneval::(Variable->Int)->Exp->Intzur Termauswer-tung.d) Definieren Sie eine FunktionvarsWithDepth::Exp->[(Variable,Int)]mit der dieListe aller in einem Ausdruck auftretenden Variablen mit der jeweiligen Tiefe im Syn-taxbaum erzeugt wird.  Nutzen Sie diese Funktion sowie die Listenfunktionenmaximum,minimumund List-Comprehension, um FunktionenminVar, minVarOfMaxD::Exp->Variablezu  definieren,  mit  denen  die  minimale  im  Ausdruck  vorkommende  Variable  bzw.   dieminimale Variable unter allen Variablen maximaler Tiefe bestimmt werden (mimimaleVariable bezieht sich auf die Ordnungsrelation<=des TypsVariable).L ̈osung:instance Show Exp whereshow (Var x)        = show x -- Typ Variable leitet Show abshow (Add e1 e2)    = "("++(show e1)++"+"++(show e2)++")"•show (Mult e1 e2 )  = "("++(show e1)++"*"++(show e2)++")"instance Eq Exp where(Var x)==(Var y)            = x==y -- Typ Variable leitet Eq ab(Add e1 e2)==(Add e3 e4)    = (e1==e3 && e2==e4) || (e1==e4 && e2==e3)(Mult e1 e2)==(Mult e3 e4)  = (e1==e3 && e2==e4) || (e1==e4 && e2==e3)=== False -- alle anderen Faelle•eal f (Var x)        = f xeval f (Add e1 e2)   = eval f e1 + eval f e2eval f (Mult e1 e2)  = eval f e1 * eval f e2help::Int->Exp->[(Variable,Int)] -- Hilfsfunktion fuer varsWithDepthhelp n (Var x)       = [(x,n)]help n (Add e1 e2)   = help (n+1) e1 ++ help (n+1) e2help n (Mult e1 e2)  = help (n+1) e1 ++ help (n+1) e2varsWithDepth e  = help 0 eminVar e         = minimum[fst pair| pair<-(varsWithDepth e)]minVarOfMaxD e   = minimum[fst pair| pair<-(varsWithDepth e), snd pair==maxD]where maxD= maximum[snd pair| pair<-(varsWithDepth e)]•2
Aufgabe 2:Strukturelle Induktion5Punktea) Nutzen Sie die Definitionen der Funktionenmap::(a->b)->[a]->[b]und(++)::[a]->[a]->[a], um mit struktureller Induktion zu beweisen, dass f ̈ur beliebigexs,ys::aundf::a->bdie  Listenmap f (xs++ys)undmap f xs ++ map f ysidentisch sind!map f [ ]       = [ ]                     -- (1)map f (x:xs)    = f x :  map f xs         -- (2)(++) [ ] ys     = ys                      -- (3)(++) (x:xs) ys  = x:(xs++ys)              -- (4)L ̈osung:Strukturelle Induktion nachn=length xs,ysist eine beliebige Liste.Zusatzkommentar:  Die verwendete Regel wird jeweils  ̈uber dem Gleicheitszeichen notierDas Gleihheitszeichen wird f ̈ur die Auswertung von Teilschritten sowohl von links nachrechts als auch von rechts nach links verwendet.Induktionsanfang:n= 0, d.h.xs = [ ]map f ([ ]++ys)(3)=map f (ys)(3)=[ ]++ map f (ys)(1)=map [ ] ++ map f (ys)Induktionsschritt:n→n+ 1, d.h.  IV:wahr f ̈urxs=⇒IB: wahr f ̈urx:xsmap f ((x:xs)++ys)(4)=map f (x:(xs++ys)(2)=(f x):map f (xs++ys)IV=(f x):(map f xs++ map f ys)•(4)=(f x:map f xs)++ map f ys(2)=(map f (x:xs))++ map f ys3
Aufgabe 3:  Auswertung und Laufzeit1 + 4 + 2Punkte +3ZusatzpunkteBetrachten Sie die Funktionenlist1, list2::Int->[Int]mitlist1 n = [x| x<-[n..2*n], y<-[x+1..4*n], (mod y x)==0]list2 n = [x| x<-[n..2*n], y<-[x+1..4*n], (mod y x)>0]Die Laufzeiten der folgenden Funktionen sollen durch die Anzahl der ausgef ̈uhrten Ver-gleichsoperationen>und==in Abh ̈angigkeit vom Parameternbestimmt werden.  DieAntworten m ̈ussen kurz begr ̈undet werden.a) Welche Laufzeit hat die Funktionhead.list1(genaue Bestimmung)?b) Bestimmen Sie m ̈oglichst gute obere Schranken f ̈ur die asymptotische Laufzeit derFunktionenlist3 n = [x| x<-list1 n, z<-[n..2*n], x==z]list4 n = [x| x<-list2 n, z<-[n..2*n], x==z]c) Weisen Sie untere Schranken f ̈ur die Funktionen aus b) nach, so dass asymptotischscharfe Schranken der Form Θ(f(n)) entstehen.d) Welches Ergebnis und welche Laufzeit, m ̈oglichst in der Form Θ(f(n)), hat die Funk-tiong n = head[x| x<-list1 (n+1), y<-list1 n, x==y]?L ̈osung:a) Bei der Auswertung(head.list1)nwird==genaunMal aufgerufen:F ̈urx=nsind die Wertey=n+ 1 bisy= 2n−1 nicht durchxteilbar.  Mity= 2nwirddie Bedingung(mod y x)==0zum ersten Mal erf ̈ullt undnals Kopfelement inlist1 naufgenommen.b) Vor ̈uberlegung:  Zur Erzeugung vonlist1 nsindO(n2) Gleichheitsabfragen ausrei-chend(Zusatzkommentar:  f ̈ur jeden dern+ 1 Werte vonxh ̈ochstens 3nWerte vony), aber die L ̈ange vonlist1 nist nurO(n), denn f ̈ur jedesxgibt es h ̈ochstens dreiy-Werte, die ein Vielfaches vonxsind.  Dagegen liegen beilist2 nLaufzeit undListenl ̈ange in =O(n2)•.Die  Laufzeit  vonlist3 n = [x| x<-list1 n, z<-[n..2*n], x==z]ist  in  0(n2),dennlist1 nwird inO(n2) Zeit erzeugt und die  ̈außere Liste erfordert auch h ̈ochstens0(n)·nVergleiche.Die  Laufzeit  vonlist4 n = [x| x<-list2 n, z<-[n..2*n], x==z]ist  in  0(n3),dennlist2 nwird inO(n2) Zeit erzeugt und die  ̈außere Liste erfordet h ̈ochstens 0(n2)·nVergleiche.c) Die Laufzeit vonlist3 nist auch in Ω(n2), weil schon die Erzeugung vonlist1 nmindestensn·2nVergleiche erfordert•.Die Laufzeit vonlist4 nist auch in Ω(n3), weil die L ̈ange vonlist2 nin Ω(n2) liegt(f ̈ur jedes x erf ̈ulleny=x+ 1 bisy= 2x+ 1 die Bedingung(mod y x)>0) und somitf ̈ur die  ̈außere Liste mindestens Ω(n2)·nVergleiche erforderlich sind•.d)  Die  Ergebnis  vong n = head[x| x<-list1 (n+1), y<-list1 n, x==y]ist  derWertn+1•und die Laufzeit liegt in Θ(n).  Dabei folgt Ω(n) schon aus a).  F ̈urdie obere Schranke beobachten wir zuerst, dass das Kopfelement vonlist1 (n+1)nachn+ 1 Vergleichen vorliegt.  Beiy<-list1 ntritt zuerst dreimal der Wertnauf, danachaber der Wertn+ 1.  Bis zum ersten Auftreten vonn+ 1 werden beim Aufruf vonlist1ninsgesamt 3n+n+ 1 Werte vony ̈uberpr ̈uft (3nf ̈urx=nundn+ 1 f ̈urx=n+ 1) -auch das ist eine lineare Anzahl•.4
Aufgabe 4:λ-Kalk ̈ul3 + 4Punktea) Reduzieren Sie denλ-AusdruckE= (λxy.xy y)(λx.y a)abso weit wie m ̈oglich.L ̈osung:(λxy.xy y)(λx.y a)ab= ((λx.(λy.xy y))(λx.y a))ab≡((λx.(λz.xz z))(λx.y a))ab   α-Konversion•≡(λz.(λx.y a)z z))abβ-Reduktion≡((λx.y a)aa)bβ-Reduktion.≡((y a)a)bβ-Reduktionb)  Formen  Sie  denλ-Ausdruck  (λxy.x)(λz.y)yin  einen   ̈aquivalenten  CL-Ausdruckum.  Zeigen Sie in den einzelnen Umformungsschritten an, welche der folgenden Umfor-mungsregeln jeweils angewendet wurde.T[ ] : Expr−→CLExpr(a)T[x] =x(b)T[E1E2] =T[E1]T[E2](c)T[λx.E] =abs(x,T[E])wobeiabs: Var×CLExpr−→CLExpr(1)abs(x,y) ={Ifalls  x=yK ysonst(2)abs(x,E) =K Efallsx6∈FV(E)(3)abs(x,E1E2) =S(abs(x,E1)) (abs(x,E2))fallsx∈FV(E1E2)L ̈osung:T[(λxy.x)(λz.y)y]   =T[λxy.x]︸︷︷︸• •T[λz.y]︸︷︷︸•T[y]︸︷︷︸zweimal (b)=abs(x,T[λy.x])abs(z,T[y])T[y]zweimal (c)=abs(x,T[λy.x])abs(z,y)yzweimal (a)=abs(x,T[λy.x])K y y(1)=abs(x,abs(y,T[x])K y y(c)=abs(x,abs(y,x)K y y(a)=abs(x,K x)K y y(1)=S abs(x,K)abs(x,x)K y y(3)=S(K K)I K y y(2) und (1)5
Aufgabe 5:Codierungen4 + 3Punktea) Bestimmen Sie f ̈ur die in der Tabelle gegebene MengeA={a,b,c,d,e,f}mit derH ̈aufigkeitsverteilungfden optimalen bin ̈aren Pr ̈afixcode mit dem Huffman-Algoritmus.Skizzieren Sie die einzelnen Schritte und tragen Sie am Ende die Codew ̈orter in die dritteZeile der Tabelle ein.Symbolx∈AabcdefH ̈aufigkeitf(x)2010522358Codierung00100101001111011L ̈osung:Die folgende Abbildung zeigt oben die geordnete Priorit ̈atswarteschlangeQnach  Initialisierung  und  unten  den  Codebaum  des  optimalen  Codes.   An  den  innerenKnoten kann die Reihenfolge der Schritte des Huffman-Algorithmus abgelesen werden.Die Codierungen wurden bereits oben in die Tabelle eingetragen.8f5c10b35e20a22d5c8f10b20a22d35eQ:100582313421. Schritt2. Schritt3. Schritt4. Schritt5. Schritt0000011111b)  Zeigen  Sie  dass  f ̈ur  jede  MengeBmitn=  2kElementena1,a2,...,anund  einerH ̈aufigkeitsverteilungf(a1)≤f(a2)≤...≤f(an)  mit  der  zus ̈atzlichen  Eigenschaftf(an)<2·f(a1) der optimale Code ein Blockcode ist (d.h.  alle Codew ̈orter haben diegleiche L ̈ange).L ̈osung:Beweis mit vollst ̈andiger Induktion nachk.Induktionsanfang:F ̈urk=  1  hatBzwei  Elemente,  die  man  optimal  mit  0  und  1codiert.Induktionsschritt:k→k+ 1.Sein= 2k+1undB={a1,...,an}eine Menge mit der H ̈aufigkeitsverteilungf(a1)≤f(a2)≤...≤f(an)  sowief(an)<2f(a1).   Um  eine  optimale  Codierung  zu  erzeu-6
gen, f ̈uhren wir den Huffman-Algorithmus aus und beobachten nach der Initialisierungdie erstenn2Schritte:  Auf Grund der Voraussetzungen   ̈uberfwerden ersta1unda2aus der WarteschlangeQentfernt und unter einer neuen Wurzela′1mit Schl ̈usselwertf(a′1) =f(a1) +f(a2) inQeingef ̈ugt, dann analoga3unda4unter neuer Wurzela′2mitf(a′2) =f(a3)+f(a4) und letztlichan−1undanuntera′n/2mitf(a′n/2) =f(an−1)+f(an).Wir beobachetn, dassB′={a′1,a′2,...,a′n/2}mitn/2 = 2kdie Bedingungen zur Anwen-dung der Induktionsvoraussetzung erf ̈ullen: Der erste Teilf(a′1)≤f(a′2)≤...≤f(a′n/2)ist offensichtlich.  Dar ̈uber hinaus giltf(a′n/2) =f(an−1) +f(an)≤2f(a1) + 2f(a1)≤2(f(a1) +f(a2)) = 2f(a′1).Folglich erzeugt der Huffman-Algorithmus einen Blockcode f ̈urB′und da alle SymboleausBin Kinderknoten vonB′-Knoten stehen, erzeugt der Huffamn-Algorithmus f ̈urBauch einen Blockcode.Aufgabe 6:Vermischtes2 + 5Punktea) Welche Werte haben die folgenden zwei Haskell-Ausdr ̈ucke?  Begr ̈undungen sind hiernicht erforderlich.length[(x,y)|x<-"basic", y<-"test", x>=y]L ̈osung:3Zusatzkommentar:  Liste enth ̈alt die Paare(’s’,’e’),(’s’,’s’)und(’i’,’e’).foldr max 0 [x+y |x<-[1..20],y<-[1,40-x]]L ̈osung:40Zusatzkommentar:  F ̈ur jedesxentsteht die gr ̈oßte Summe mity= 40−x, also ist 40das (mehrfach auftretende) Maximum in der Liste.b)  Bestimmen  Sie  den  allgemeinst  m ̈oglichen  Typ  f ̈ur  die  folgenden  Ausdr ̈ucke  undbegr ̈unden Sie kurz Ihre Antworten:f x y z = "abcd"++ map x [d | d<-y, d<= lentgh z]L ̈osung:f ::  (Int->Char)->[Int]->[a]->[Char]•Begr ̈undung:Ausgabetyp muss String sein (wegen"abcd"++...)  und somit muss auch das Ergebnisvonmap x [d | d<-y, d<= lentgh z]ein String sein.Nach Definition istmap::(a->b)->[a]->[b]und somitx::a->b,b=Char,[d | d<-y, d<= lentgh z]::[a]und letztlichy::[a].  Da die Elemente vonymitlength zvergleichen werden, mussa=Intundzein beliebiger Listentyp sein.•g  x y z|foldr y (y x x) z  = [ ]|otherwise          = [z]L ̈osung:g ::  Bool->(Bool->Bool->Bool)->[Bool]->[[Bool]]•Begr ̈undung:Dafoldr y (y x x) zals Bedingung auftritt, muss dieser Ausdruckvom  TypBoolsein.   Nach  Definition  istfoldr::(a->b->b)->b->[a]->bund  somitb=Bool, sowiey::a->Bool->Boolundx::Bool.  Wegen der Anwendungy x xmussa=b=Boolsein, alsoz::[a]=[Bool]und da die Ausgabe vongim zweiten Fall[z]ist,muss der Ausgabetyp vonggleich[[Bool]]sein.•7
